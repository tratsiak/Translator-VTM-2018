#include "stdafx.h"


int PN::prior(char znak)
{
	switch (znak)
	{
	case '+':
	case '-':
		return 2;
	case '*':
	case '/':
		return 3;
	default:
		return 0;
	}
}


int PN::searchExpression(int index, LeX::LEX *tables) //поиск выражения
{
	for (int i = index; i < tables->Lextable.size; i++) //перебор лексем
	{
		if (tables->Lextable.table[i].lexema == PLUS || tables->Lextable.table[i].lexema == MINUS
			|| tables->Lextable.table[i].lexema == MULT || tables->Lextable.table[i].lexema == DEV) //находим операцию
		{
			for (; ; i--) //перебираем лексемы обратно
			{
				if (tables->Lextable.table[i].lexema == EQUAL || tables->Lextable.table[i].lexema == RH)
					return i + 1;
			}
		}
	}
	return -1; //если не нашли возвращаем минус 1
}

bool PN::CreatePolishNotation(LeX::LEX *tables)
{
	stack <LT::Entry> stack_operators;// хранятся операторы
	bool build = false;

	int i = 0;
	int j = 0;
	int k = 0;

	while (searchExpression(i, tables) != -1)
	{
		j = i = searchExpression(i, tables);//индекс первого символа после равно
		bool isOne = false;
		for (; tables->Lextable.table[i].lexema != LEX_SEPARATOR; i++, k++) //читаем до символа конца строки, увеличивая счётчик К
		{
			if (tables->Lextable.table[i].lexema == LH || tables->Lextable.table[i].lexema == RH) //если нашли ( или )
			{
				switch (tables->Lextable.table[i].lexema) //смотрим какая лексема
				{
				case LH:
				{
					if ((tables->Lextable.table[i - 1].idxTI != -1 && tables->IDtable.table[tables->Lextable.table[i - 1].idxTI].idtype == IT::F)
						|| tables->Lextable.table[i - 1].lexema == 'a' || tables->Lextable.table[i - 1].lexema == 's')  // Вернёт -1 если это не будет являтся переменной
					{
						while (tables->Lextable.table[i - 1].lexema != RH)
							i++;
						break;
					}
					stack_operators.push(tables->Lextable.table[i]);// ( добавляем в стек Операторов элемент таблицы лексем
					break;
				}
				case RH:
					while (stack_operators.top().lexema != LH) // ) посмотреть вехний элемент из стека
					{
						result[size++] = stack_operators.top();
						stack_operators.pop(); //извлекает вершину стека операторов
					}
					stack_operators.pop(); //извлекает вершину стека операторов
					break;
				}
			}
			else
			{
				switch (tables->Lextable.table[i].lexema) //если это не скобки()
				{
				case MULT:
				case DEV:
				{
					stack_operators.push(tables->Lextable.table[i]);//добавляем в стек Операторов элемент таблицы лексем
					break;
				}
				case PLUS:
				case MINUS:
					if (stack_operators.empty() || prior(tables->Lextable.table[i].lexema) == prior(stack_operators.top().lexema))//пуст
						stack_operators.push(tables->Lextable.table[i]);//добавляем в стек Операторов элемент таблицы лексем 
					else //стек Операторов не пустой
					{
						while (!stack_operators.empty() && stack_operators.top().lexema != LH &&
							prior(tables->Lextable.table[i].lexema) < prior(stack_operators.top().lexema)) //если лексема в стеке не (, и приоретет операции меньше либо равен приоритету лежащему в голове стека, то..
						{
							result[size++] = stack_operators.top(); //заносим верхушку стека в результат
							stack_operators.pop();//извлекает верхушку стека
						}
						if (!stack_operators.empty() && stack_operators.top().lexema == LH)// проверяем верхушку стека
							stack_operators.push(tables->Lextable.table[i]);//добавить в стек операторов элемент таблицы лексем
						if (stack_operators.empty())// проверяем верхушку стека
							stack_operators.push(tables->Lextable.table[i]);//добавить в стек операторов элемент таблицы лексем
					}
					break;
				default:
				{
					result[size++] = tables->Lextable.table[i];//заносим таблицу лексем в результат
					break;
				}
				}
			}
		}
		for (; !stack_operators.empty(); i++)	//выбить все операторы в Выходной стек
		{
			result[size++] = stack_operators.top(); //заносим все оперыторы в результат
			stack_operators.pop();// вынимаем верхушку стека
		}
		for (int i = 0; i < size; j++, i++, k--) //заполняяем таблицу лексем, для данного выражения
		{
			tables->Lextable.table[j].lexema = result[i].lexema;
			tables->Lextable.table[j].idxTI = result[i].idxTI;
			tables->Lextable.table[j].sn = result[i].sn; //номер стр в исх текcт
			tables->IDtable.table[result[i].idxTI].idxfirstLE;
		}
		for (; k > 0; k--, j++)	//заместить все элементы, "удалённые в процессе создания польской"
		{
			tables->Lextable.table[j].lexema = NULL;
			tables->Lextable.table[j].idxTI = NULL;
		}
		size = 0;
		build = true;
	}
	return build;
}